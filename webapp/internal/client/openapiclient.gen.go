// Code generated by openapi-client. DO NOT EDIT.

package client

import (
	context "context"
	json "encoding/json"
	fmt "fmt"
	io "io"
	http "net/http"
	url "net/url"
)

// Status represents the current setup status.
type Status struct {
	// status id
	Id int
	// a textual representation as a developer notice
	Message string
}

//
// MercuriusService is a basic http client implementation, which provides some reasonable defaults
type MercuriusService struct {
	baseURL    *url.URL
	userAgent  string
	httpClient *http.Client
}

// NewMercuriusService creates a new service instance. If httpClient is nil, the default client is used.
func NewMercuriusService(baseURL *url.URL, userAgent string, httpClient *http.Client) *MercuriusService {
	if httpClient == nil {
		httpClient = http.DefaultClient
	}
	return &MercuriusService{baseURL: baseURL, httpClient: httpClient, userAgent: userAgent}
}

func (s *MercuriusService) newRequest(ctx context.Context, method, path, contentType, accept string, body io.Reader) (*http.Request, error) {
	rel := &url.URL{Path: path}
	u := s.baseURL.ResolveReference(rel)
	req, err := http.NewRequestWithContext(ctx, method, u.String(), body)
	if err != nil {
		return nil, err
	}
	if body != nil {
		req.Header.Set("Content-Type", contentType)
	}

	req.Header.Set("Accept", accept)
	if s.userAgent != "" {
		req.Header.Set("User-Agent", s.userAgent)
	}
	return req, nil
}

func (s *MercuriusService) doJson(req *http.Request, v interface{}) (*http.Response, error) {
	resp, err := s.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	err = json.NewDecoder(resp.Body).Decode(v)
	return resp, err
}

// SetupService returns the according api group
func (s *MercuriusService) SetupService() SetupService {
	return SetupService{parent: s}
}

// SetupService groups tagged api calls
type SetupService struct {
	parent *MercuriusService
}

// Status returns the current setup status. This is usually only relevant in the installation phase.
func (_self SetupService) syncApiV1SetupStatus(_ctx context.Context) ([]Status, error) {
	var _res []Status
	path := fmt.Sprintf("/api/v1/setup/status")
	_req, _err := _self.parent.newRequest(_ctx, "GET", path, "", "application/json", nil)
	if _err != nil {
		return _res, _err
	}
	_, _err = _self.parent.doJson(_req, &_res)
	return _res, _err
}

// Status returns the current setup status. This is usually only relevant in the installation phase.
func (_self SetupService) ApiV1SetupStatus(_ctx context.Context, f func(res []Status, err error)) {
	go func() {
		res, err := _self.syncApiV1SetupStatus(_ctx)
		f(res, err)
	}()
}

// Code generated by openapi-client. DO NOT EDIT.

package client

import (
	context "context"
	json "encoding/json"
	fmt "fmt"
	uuid "github.com/golangee/uuid"
	io "io"
	ioutil "io/ioutil"
	http "net/http"
	url "net/url"
	reflect "reflect"
)

// Status represents the current setup status.
type Status struct {
	//
	ID2 uuid.UUID
	// status id
	Id int
	// a textual representation as a developer notice
	Message string
}

// Error describes a (nested) server error
type Error struct {
	Id               string      `json:"id"`                         // Id is unique for a specific error, e.g. mydomain.not.assigned
	Message          string      `json:"message"`                    // Message is a string for the developer
	LocalizedMessage string      `json:"localizedMessage,omitempty"` // LocalizedMessage is something to display the user
	CausedBy         *Error      `json:"causedBy,omitempty"`         // CausedBy returns an optional root error
	Type             string      `json:"type,omitempty"`             // Type is a developer notice for the internal inspection
	Details          interface{} `json:"details,omitempty"`          // Details contains arbitrary payload
}

// WrapError takes the cause and converts it into an Error for later serialization.
func WrapError(id string, causedBy error) *Error {
	msg := id
	if causedBy != nil {
		msg = causedBy.Error()
	}
	return &Error{Id: id, Message: msg, CausedBy: AsError(causedBy)}
}

// ParseError tries to parse the response as json. In any case it returns an error.
func ParseError(reader io.Reader) *Error {
	buf, err := ioutil.ReadAll(reader)
	if err != nil {
		return AsError(err)
	}

	res := &Error{}
	err = json.Unmarshal(buf, res)
	if err != nil {
		return AsError(err)
	}

	return res
}

// ID returns the unique error class id
func (c *Error) ID() string {
	return c.Id
}

// Error returns the message
func (c *Error) Error() string {
	return c.Message
}

// LocalizedError is like Error but translated or empty
func (c *Error) LocalizedError() string {
	return c.LocalizedMessage
}

// Class returns the technical type
func (c *Error) Class() string {
	return c.Type
}

// Payload returns the details
func (c *Error) Payload() interface{} {
	return c.Details
}

// Unwrap returns the cause or nil
func (c *Error) Unwrap() error {
	if c.CausedBy == nil { // otherwise error iface will not be nil, because of the type info in interface
		return nil
	}
	return c.CausedBy
}

func (c *Error) String() string {
	buf, err2 := json.Marshal(AsError(c))
	if err2 != nil {
		return fmt.Errorf("suppressed error by: %w", err2).Error()
	}
	return string(buf)
}

// FindError returns the first occurrence of the error identified by id or nil.
func FindError(err error, id string) *Error {
	if err == nil {
		return nil
	}

	e := AsError(err)
	if e.Id == id {
		return e
	}

	if e.CausedBy != nil {
		return FindError(e.CausedBy, id)
	}

	return nil
}

// AsError either casts the given error (if possible) or creates a new Error from the given error. Returns only
// nil if err is nil.
func AsError(err error) *Error {
	if err == nil {
		return nil
	}

	if e, ok := err.(*Error); ok {
		return e
	}

	e := &Error{}
	e.Type = reflect.TypeOf(err).String()
	e.Message = err.Error()

	if code, ok := err.(interface{ ID() string }); ok {
		e.Id = code.ID()
	} else {
		e.Id = e.Type
	}

	if details, ok := err.(interface{ Payload() interface{} }); ok {
		e.Details = details
	}

	if localized, ok := err.(interface{ LocalizedError() string }); ok {
		e.LocalizedMessage = localized.LocalizedError()
	}

	if class, ok := err.(interface{ Class() string }); ok {
		e.Type = class.Class()
	}

	if wrapper, ok := err.(interface{ Unwrap() error }); ok {
		cause := wrapper.Unwrap()
		if cause != nil {
			tmp := AsError(cause)
			e.CausedBy = tmp
		}
	}

	return e
}

//
// MercuriusService is a basic http client implementation, which provides some reasonable defaults
type MercuriusService struct {
	baseURL    *url.URL
	userAgent  string
	httpClient *http.Client
}

// NewMercuriusService creates a new service instance. If httpClient is nil, the default client is used.
func NewMercuriusService(baseURL *url.URL, userAgent string, httpClient *http.Client) *MercuriusService {
	if httpClient == nil {
		httpClient = http.DefaultClient
	}
	return &MercuriusService{baseURL: baseURL, httpClient: httpClient, userAgent: userAgent}
}

func (s *MercuriusService) newRequest(ctx context.Context, method, path, contentType, accept string, body io.Reader) (*http.Request, error) {
	rel := &url.URL{Path: path}
	u := s.baseURL.ResolveReference(rel)
	req, err := http.NewRequestWithContext(ctx, method, u.String(), body)
	if err != nil {
		return nil, err
	}
	if body != nil {
		req.Header.Set("Content-Type", contentType)
	}

	req.Header.Set("Accept", accept)
	if s.userAgent != "" {
		req.Header.Set("User-Agent", s.userAgent)
	}
	return req, nil
}

func (s *MercuriusService) doJson(req *http.Request, v interface{}) (*http.Response, error) {
	resp, err := s.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode == 200 {
		err = json.NewDecoder(resp.Body).Decode(v)
		return resp, err
	} else {
		err := ParseError(resp.Body)
		return resp, err
	}

}

// SetupService returns the according api group
func (s *MercuriusService) SetupService() SetupService {
	return SetupService{parent: s}
}

// SetupService groups tagged api calls
type SetupService struct {
	parent *MercuriusService
}

// Status returns the current setup status. This is usually only relevant in the installation phase.
func (_self SetupService) syncApiV1SetupStatus(_ctx context.Context) ([]Status, error) {
	var _res []Status
	path := fmt.Sprintf("/api/v1/setup/status")
	_req, _err := _self.parent.newRequest(_ctx, "GET", path, "", "application/json", nil)
	if _err != nil {
		return _res, _err
	}
	_, _err = _self.parent.doJson(_req, &_res)
	return _res, _err
}

// Status returns the current setup status. This is usually only relevant in the installation phase.
func (_self SetupService) ApiV1SetupStatus(_ctx context.Context, f func(res []Status, err error)) {
	go func() {
		res, err := _self.syncApiV1SetupStatus(_ctx)
		f(res, err)
	}()
}
